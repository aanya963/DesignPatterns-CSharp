"Singleton ensures a class has only one instance and provides a global access point to it, 
typically implemented using private constructor, static instance, and static access method."


1ï¸âƒ£ What is Singleton?
    Singleton ensures:
       - Only one instance of a class exists
       - A global access point is provided to access that instance
2ï¸âƒ£ Core Rules in C#
    A proper Singleton must have:
    private constructor
    static instance field
    public static access method/property

3ï¸âƒ£ Why Constructor Must Be Private?
If constructor is public:
    new Singleton(); âŒ
    Anyone can create multiple objects.
Private constructor ensures:
    Object can only be created inside the class
4ï¸âƒ£ Why Instance Must Be Static?
Because Singleton belongs to the class, not to an object.
Static:
    Shared across application
    Only one copy exists

5ï¸âƒ£ Types of Singleton in C#
ğŸ”¹ 1. Basic Singleton (Lazy â€“ NOT Thread Safe)
    âœ” Lazy initialization
    âŒ Not thread-safe
    âœ” Easy to understand
Use only for learning.

ğŸ”¹ 2. Eager Initialization Singleton
    âœ” Thread-safe by default (CLR guarantees static initialization safety)
    âœ” Very simple
    âŒ Instance created even if not used
Good when:
    Object is lightweight
    Always needed

ğŸ”¹ 3. Thread-Safe Singleton (Using lock)
    âœ” Lazy
    âœ” Thread-safe
    âŒ Locking on every call (performance overhead)
Used before Lazy<T> became popular.

ğŸ”¹ 4. Lazy<T> Singleton (Best Practice in Modern C#)
    âœ” Lazy
    âœ” Thread-safe
    âœ” No manual locking
    âœ” Clean and recommended
This is the most elegant solution in C#.

6ï¸âƒ£ Which One Should I Use?
If object is lightweight: â†’ Use Eager Singleton

If object is heavy or may not always be used: â†’ Use Lazy<T> Singleton

Avoid: â†’ Basic Singleton in multithreaded applications

7ï¸âƒ£ C# Specific Advantages
âœ” CLR Handles Static Initialization
In C#:
    Static fields are initialized only once
    Thread-safe by default
    No race condition during class loading
    This makes Eager Singleton safe.

âœ” Built-in Lazy<T>
C# provides: Lazy<T>
Which:
    Handles thread-safety
    Handles lazy initialization
    Avoids manual locking
    This is not as cleanly available in C++.

âœ” lock Keyword
C# provides simple synchronization:
    lock(object)
    Internally uses Monitor class.
    Much simpler compared to manual mutex handling in C++.

8ï¸âƒ£ Why Use sealed in C#?
    public sealed class Singleton
    Prevents inheritance.
    If not sealed:
    A derived class could create another instance
    Singleton guarantee may break
    Best practice in C#:
    Always mark Singleton as sealed.
9ï¸âƒ£ Real-World Use Cases
    Logger
    Configuration Manager
    Cache Manager
    Database Connection Manager
    Application-wide settings
ğŸ”Ÿ Problems With Singleton
    âŒ Hard to unit test
    âŒ Global state can increase coupling
    âŒ Can hide dependencies
Use carefully in large systems.

Preferred Order:
ğŸ¥‡ Lazy<T>
ğŸ¥ˆ Eager Initialization
ğŸ¥‰ Lock-based Thread Safe
âŒ Basic (only for learning)